package com.example.intellijwebviewsample

import com.intellij.openapi.application.ApplicationManager
import com.intellij.openapi.components.service
import com.intellij.openapi.diagnostic.thisLogger
import com.intellij.openapi.project.Project
import com.intellij.ui.jcef.JBCefBrowser
import com.intellij.ui.jcef.JBCefJSQuery
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import com.fasterxml.jackson.module.kotlin.registerKotlinModule
import java.awt.BorderLayout
import java.util.*
import javax.swing.JComponent
import javax.swing.JPanel

/**
 * WebView Terminal Panel
 * VS Code ExtensionÏùò webviewÏôÄ Ïú†ÏÇ¨Ìïú Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.
 * JCEF (Java Chromium Embedded Framework)Î•º ÏÇ¨Ïö©ÌïòÏó¨ Ïõπ Í∏∞Î∞ò ÌÑ∞ÎØ∏ÎÑê UIÎ•º Íµ¨ÌòÑÌï©ÎãàÎã§.
 */
class WebViewTerminalPanel(private val project: Project) {
    
    private val logger = thisLogger()
    private val objectMapper = ObjectMapper().registerKotlinModule()
    private val terminalService = project.service<TerminalService>()
    private val browser = JBCefBrowser()
    private val panel = JPanel(BorderLayout())
    private var isTerminalReady = false
    
    init {
        setupWebView()
        setupMessageHandling()
        panel.add(browser.component, BorderLayout.CENTER)
    }
    
    fun getComponent(): JComponent = panel
    
    private fun setupWebView() {
        logger.info("üîß Setting up WebView...")
        
        // HTML ÏΩòÌÖêÏ∏† Î°úÎìú
        browser.loadHTML(getWebViewContent())
        
        logger.info("‚úÖ WebView setup completed")
    }
    
    private fun setupMessageHandling() {
        logger.info("üîß Setting up message handling...")
        
        // JavaScriptÏóêÏÑú KotlinÏúºÎ°ú Î©îÏãúÏßÄÎ•º Î≥¥ÎÇ¥Í∏∞ ÏúÑÌïú ÏøºÎ¶¨ Ìï∏Îì§Îü¨
        val jsQuery = JBCefJSQuery.create(browser)
        
        jsQuery.addHandler { query ->
            try {
                logger.info("üì® Received message from WebView: $query")
                
                val message = objectMapper.readValue<Map<String, Any>>(query)
                val command = message["command"] as? String
                
                when (command) {
                    "createTerminal" -> {
                        handleCreateTerminal()
                    }
                    "executeCommand" -> {
                        val commandText = message["commandText"] as? String
                        if (commandText != null) {
                            handleExecuteCommand(commandText)
                        }
                    }
                    "userInput" -> {
                        val input = message["input"] as? String
                        if (input != null) {
                            handleUserInput(input)
                        }
                    }
                    "terminateTerminal" -> {
                        handleTerminateTerminal()
                    }
                    "killProcess" -> {
                        handleKillProcess()
                    }
                    "clearTerminal" -> {
                        handleClearTerminal()
                    }
                    "checkTerminalStatus" -> {
                        handleCheckTerminalStatus()
                    }
                    else -> {
                        logger.warn("‚ùì Unknown command: $command")
                    }
                }
                
                JBCefJSQuery.Response("ok")
            } catch (e: Exception) {
                logger.error("‚ùå Error handling message from WebView", e)
                JBCefJSQuery.Response(null, 0, "Error: ${e.message}")
            }
        }
        
        // JavaScriptÏóêÏÑú ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎèÑÎ°ù Ï†ÑÏó≠ Ìï®Ïàò Îì±Î°ù
        browser.jbCefClient.addLoadHandler(object : org.cef.handler.CefLoadHandlerAdapter() {
            override fun onLoadEnd(browser: org.cef.browser.CefBrowser?, frame: org.cef.browser.CefFrame?, httpStatusCode: Int) {
                if (frame?.isMain == true) {
                    // JavaScriptÏóêÏÑú Kotlin Ìï®ÏàòÎ•º Ìò∏Ï∂úÌï† Ïàò ÏûàÎèÑÎ°ù Ï†ÑÏó≠ Ìï®Ïàò Îì±Î°ù
                    val script = """
                        window.sendToKotlin = function(data) {
                            ${jsQuery.inject("JSON.stringify(data)")}
                        };
                    """.trimIndent()
                    
                    browser?.executeJavaScript(script, browser.url, 0)
                    logger.info("‚úÖ JavaScript bridge initialized")
                }
            }
        }, browser.cefBrowser)
        
        // ÌÑ∞ÎØ∏ÎÑê ÏÑúÎπÑÏä§ Ï∂úÎ†• Î¶¨Ïä§ÎÑà Îì±Î°ù
        terminalService.addOutputListener("webview") { output, isError ->
            sendToWebView(mapOf(
                "command" to "terminalOutput",
                "data" to output,
                "isError" to isError
            ))
        }
        
        logger.info("‚úÖ Message handling setup completed")
    }
    
    private fun handleCreateTerminal() {
        logger.info("üöÄ Creating terminal...")
        
        val success = terminalService.initializeTerminal()
        if (success) {
            isTerminalReady = true
            sendToWebView(mapOf(
                "command" to "terminalReady",
                "method" to "IntelliJ Process Handler"
            ))
        } else {
            sendToWebView(mapOf(
                "command" to "terminalError",
                "error" to "Failed to create terminal"
            ))
        }
    }
    
    private fun handleExecuteCommand(commandText: String) {
        logger.info("‚ñ∂Ô∏è Executing command: $commandText")
        
        if (!isTerminalReady) {
            terminalService.initializeTerminal()
            isTerminalReady = true
        }
        
        terminalService.executeCommand(commandText)
    }
    
    private fun handleUserInput(input: String) {
        logger.info("‚å®Ô∏è User input: $input")
        handleExecuteCommand(input)
    }
    
    private fun handleTerminateTerminal() {
        logger.info("üîÑ Terminating terminal...")
        
        terminalService.terminateTerminal()
        isTerminalReady = false
        
        sendToWebView(mapOf(
            "command" to "terminalTerminated"
        ))
    }
    
    private fun handleKillProcess() {
        logger.info("‚ö° Killing current process...")
        terminalService.killCurrentProcess()
    }
    
    private fun handleClearTerminal() {
        logger.info("üßπ Clearing terminal...")
        terminalService.clearTerminal()
        
        sendToWebView(mapOf(
            "command" to "clearWebTerminal"
        ))
    }
    
    private fun handleCheckTerminalStatus() {
        logger.info("üìä Checking terminal status...")
        
        val status = terminalService.getTerminalStatus()
        sendToWebView(mapOf(
            "command" to "terminalStatus",
            "isActive" to (status["isActive"] ?: false),
            "hasRunningProcess" to (status["hasRunningProcess"] ?: false),
            "currentDirectory" to (status["currentDirectory"] ?: "")
        ))
    }
    
    private fun sendToWebView(data: Map<String, Any>) {
        ApplicationManager.getApplication().invokeLater {
            try {
                val json = objectMapper.writeValueAsString(data)
                val script = "window.handleMessage && window.handleMessage($json);"
                browser.cefBrowser.executeJavaScript(script, browser.cefBrowser.url, 0)
            } catch (e: Exception) {
                logger.error("‚ùå Error sending message to WebView", e)
            }
        }
    }
    
    private fun getWebViewContent(): String {
        return """
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
    <style>
        body { 
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            background: #2b2b2b;
            color: #a9b7c6;
            margin: 0;
            padding: 20px;
        }
        .card {
            background: #3c3f41;
            border: 1px solid #555555;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        button {
            background: #4c5052;
            color: #a9b7c6;
            border: 1px solid #555555;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }
        button:hover {
            background: #5c6162;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .terminal-container {
            background: #000;
            border: 1px solid #555555;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            height: 400px;
            overflow: hidden;
        }
        .terminal-info {
            background: #313335;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
        }
        input {
            width: 70%;
            padding: 8px;
            margin: 10px 5px;
            background: #313335;
            color: #a9b7c6;
            border: 1px solid #555555;
            border-radius: 4px;
            font-family: inherit;
        }
        .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
        .status.ready {
            background: #365880;
            color: white;
        }
        .status.error {
            background: #743a3a;
            color: white;
        }
        .status.pending {
            background: #7a6a2c;
            color: white;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
        }
        .terminal-controls {
            margin-bottom: 10px;
        }
        #terminal {
            height: 100%;
            width: 100%;
        }
        .intellij-mode {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
        }
        .danger-btn {
            background: #743a3a !important;
            color: white !important;
        }
        .danger-btn:hover {
            background: #8b4a4a !important;
        }
        .warning-btn {
            background: #7a6a2c !important;
            color: white !important;
        }
        .warning-btn:hover {
            background: #8b7a3c !important;
        }
    </style>
</head>
<body>
    <h1>üöÄ IntelliJ WebView Terminal</h1>
    
    <div class="intellij-mode">
        <strong>üéØ IntelliJ + Process Handler Î™®Îìú</strong><br>
        VS Code PseudoterminalÍ≥º ÎèôÏùºÌïú Í∏∞Îä•ÏùÑ IntelliJÏóêÏÑú Íµ¨ÌòÑÌñàÏäµÎãàÎã§!
    </div>
    
    <div class="card">
        <h2>üìü Process Handler Ï†úÏñ¥</h2>
        <p>IntelliJÏùò ProcessHandlerÎ•º ÏÇ¨Ïö©Ìïú Ïã§Ï†ú Ïâò ÌîÑÎ°úÏÑ∏Ïä§ Ï†úÏñ¥</p>
        
        <div class="terminal-controls">
            <button onclick="createTerminal()">ÌÑ∞ÎØ∏ÎÑê ÏÉùÏÑ±</button>
            <button onclick="terminateTerminal()" id="terminateBtn" class="danger-btn">ÌÑ∞ÎØ∏ÎÑê Ï¢ÖÎ£å</button>
            <button onclick="killProcess()" id="killBtn" class="warning-btn">ÌîÑÎ°úÏÑ∏Ïä§ Í∞ïÏ†úÏ¢ÖÎ£å</button>
            <button onclick="clearTerminal()" id="clearBtn">ÌÑ∞ÎØ∏ÎÑê ÏßÄÏö∞Í∏∞</button>
            <button onclick="checkStatus()" id="statusBtn">ÏÉÅÌÉú ÌôïÏù∏</button>
            <span id="terminalStatus" class="status">ÎåÄÍ∏∞Ï§ë</span>
        </div>
        
        <div class="terminal-info" id="terminalInfo">
            IntelliJ ProcessHandlerÎ•º ÏÇ¨Ïö©ÌïòÏó¨ Ïã§Ï†ú Ïâò ÌîÑÎ°úÏÑ∏Ïä§Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.<br/>
            VS Code PseudoterminalÍ≥º ÎèôÏùºÌïú Î∞©ÏãùÏúºÎ°ú ÎèôÏûëÌï©ÎãàÎã§!
        </div>
    </div>
    
    <div class="card">
        <h2>üñ•Ô∏è xterm.js ÌÑ∞ÎØ∏ÎÑê</h2>
        <div class="terminal-container">
            <div id="terminal"></div>
        </div>
    </div>
    
    <div class="card">
        <h2>üîß Îπ†Î•∏ Î™ÖÎ†πÏñ¥</h2>
        <p>Ïã§Ï†ú Ïâò ÏÑ∏ÏÖòÏóêÏÑú Ïã§ÌñâÎêòÎØÄÎ°ú cd, export Îì±Ïù¥ Îã§Ïùå Î™ÖÎ†πÏñ¥ÏóêÎèÑ Ïú†ÏßÄÎê©ÎãàÎã§!</p>
        <div class="button-group">
            <button onclick="executeCommand('ls -la')" class="cmd-btn">ls -la</button>
            <button onclick="executeCommand('pwd')" class="cmd-btn">pwd</button>
            <button onclick="executeCommand('whoami')" class="cmd-btn">whoami</button>
            <button onclick="executeCommand('cd /tmp')" class="cmd-btn">cd /tmp</button>
            <button onclick="executeCommand('pwd')" class="cmd-btn">pwd (Îã§Ïãú)</button>
            <button onclick="executeCommand('export TEST=hello')" class="cmd-btn">export TEST=hello</button>
            <button onclick="executeCommand('echo ${'$'}TEST')" class="cmd-btn">echo ${'$'}TEST</button>
            <button onclick="executeCommand('date')" class="cmd-btn">ÎÇ†Ïßú</button>
            <button onclick="executeCommand('java -version')" class="cmd-btn">Java Î≤ÑÏ†Ñ</button>
            <button onclick="executeCommand('gradle --version')" class="cmd-btn">Gradle Î≤ÑÏ†Ñ</button>
        </div>
        
        <div style="margin-top: 15px;">
            <input id="customCommand" placeholder="ÏÇ¨Ïö©Ïûê Ï†ïÏùò Î™ÖÎ†πÏñ¥ ÏûÖÎ†•" onkeypress="handleCommandKey(event)">
            <button onclick="executeCustomCommand()">Ïã§Ìñâ</button>
        </div>
        
        <div style="margin-top: 10px;">
            <small>üí° IntelliJ ProcessHandler + JCEF WebViewÎ°ú Íµ¨ÌòÑÎêú ÌÑ∞ÎØ∏ÎÑêÏûÖÎãàÎã§!</small>
        </div>
    </div>

    <script>
        let terminalReady = false;
        let term;
        let fitAddon;
        let currentLine = '';
        let commandHistory = [];
        let historyIndex = -1;
        
        // xterm.js ÌÑ∞ÎØ∏ÎÑê Ï¥àÍ∏∞Ìôî
        function initTerminal() {
            if (term) {
                term.dispose();
            }
            
            term = new Terminal({
                cursorBlink: true,
                fontSize: 14,
                fontFamily: 'JetBrains Mono, Consolas, monospace',
                theme: {
                    background: '#1e1e1e',
                    foreground: '#a9b7c6',
                    cursor: '#a9b7c6',
                    selection: '#214283',
                    black: '#000000',
                    red: '#ff6b68',
                    green: '#a8c023',
                    yellow: '#f77669',
                    blue: '#6897bb',
                    magenta: '#cc7832',
                    cyan: '#629755',
                    white: '#a9b7c6',
                    brightBlack: '#555555',
                    brightRed: '#ff8785',
                    brightGreen: '#bcd42a',
                    brightYellow: '#ffc66d',
                    brightBlue: '#9cc7ea',
                    brightMagenta: '#ff9137',
                    brightCyan: '#7eb369',
                    brightWhite: '#ffffff'
                }
            });
            
            // Fit addon Ï¥àÍ∏∞Ìôî
            fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            
            // ÌÑ∞ÎØ∏ÎÑêÏùÑ DOMÏóê Ïó∞Í≤∞
            term.open(document.getElementById('terminal'));
            fitAddon.fit();
            
            // ÌÑ∞ÎØ∏ÎÑê Î¶¨ÏÇ¨Ïù¥Ï¶à Ï≤òÎ¶¨
            window.addEventListener('resize', () => {
                if (fitAddon) {
                    fitAddon.fit();
                }
            });
            
            // ÏÇ¨Ïö©Ïûê ÏûÖÎ†• Ï≤òÎ¶¨
            term.onData(data => {
                const code = data.charCodeAt(0);
                
                // Ctrl+C Ï≤òÎ¶¨ (ÌîÑÎ°úÏÑ∏Ïä§ Ï§ëÎã®)
                if (code === 3) { // Ctrl+C
                    sendToKotlin({
                        command: 'killProcess'
                    });
                    term.write('^C\\r\\n\$ ');
                    currentLine = '';
                    return;
                }
                
                if (code === 13) { // Enter
                    if (currentLine.trim()) {
                        console.log('Sending user input:', currentLine.trim());
                        
                        // Î™ÖÎ†πÏñ¥ Ïã§Ìñâ
                        commandHistory.push(currentLine.trim());
                        historyIndex = commandHistory.length;
                        
                        term.write('\\r\\n');
                        sendToKotlin({
                            command: 'userInput',
                            input: currentLine.trim()
                        });
                        currentLine = '';
                    } else {
                        term.write('\\r\\n\$ ');
                    }
                } else if (code === 127) { // Backspace
                    if (currentLine.length > 0) {
                        currentLine = currentLine.slice(0, -1);
                        term.write('\\b \\b');
                    }
                } else if (code === 27) { // Escape sequences (ÌôîÏÇ¥Ìëú ÌÇ§ Îì±)
                    if (data.length === 3) {
                        if (data[2] === 'A') { // Up arrow
                            if (historyIndex > 0) {
                                term.write('\\r\$ ');
                                term.write(' '.repeat(currentLine.length));
                                term.write('\\r\$ ');
                                
                                historyIndex--;
                                currentLine = commandHistory[historyIndex];
                                term.write(currentLine);
                            }
                        } else if (data[2] === 'B') { // Down arrow
                            if (historyIndex < commandHistory.length - 1) {
                                term.write('\\r\$ ');
                                term.write(' '.repeat(currentLine.length));
                                term.write('\\r\$ ');
                                
                                historyIndex++;
                                currentLine = commandHistory[historyIndex];
                                term.write(currentLine);
                            } else if (historyIndex === commandHistory.length - 1) {
                                term.write('\\r\$ ');
                                term.write(' '.repeat(currentLine.length));
                                term.write('\\r\$ ');
                                
                                historyIndex = commandHistory.length;
                                currentLine = '';
                            }
                        }
                    }
                } else if (code >= 32) { // ÏùºÎ∞ò Î¨∏Ïûê
                    currentLine += data;
                    term.write(data);
                }
            });
            
            // Ï¥àÍ∏∞ ÌîÑÎ°¨ÌîÑÌä∏ ÌëúÏãú
            term.write('üéØ IntelliJ xterm.js ÌÑ∞ÎØ∏ÎÑêÏù¥ Ï§ÄÎπÑÎêòÏóàÏäµÎãàÎã§!\\r\\n\$ ');
        }
        
        function createTerminal() {
            initTerminal();
            sendToKotlin({ command: 'createTerminal' });
            updateStatus('ÏÉùÏÑ±Ï§ë...', 'pending');
        }
        
        function executeCommand(cmd) {
            if (!cmd.trim()) return;
            
            if (term) {
                term.write('\\r\\n> ' + cmd + '\\r\\n');
                currentLine = '';
            }
            
            sendToKotlin({ 
                command: 'executeCommand', 
                commandText: cmd
            });
        }
        
        function executeCustomCommand() {
            const input = document.getElementById('customCommand');
            const cmd = input.value.trim();
            if (cmd) {
                executeCommand(cmd);
                input.value = '';
            }
        }
        
        function handleCommandKey(event) {
            if (event.key === 'Enter') {
                executeCustomCommand();
            }
        }
        
        function clearTerminal() {
            if (term) {
                term.clear();
                term.write('\$ ');
                currentLine = '';
            }
            sendToKotlin({ command: 'clearTerminal' });
        }
        
        function terminateTerminal() {
            sendToKotlin({ command: 'terminateTerminal' });
            updateStatus('Ï¢ÖÎ£åÏ§ë...', 'pending');
            
            if (term) {
                term.clear();
                term.write('üîÑ ÌÑ∞ÎØ∏ÎÑêÏùÑ Ï¢ÖÎ£åÌïòÍ≥† ÏûàÏäµÎãàÎã§...');
            }
            
            commandHistory = [];
            historyIndex = -1;
            currentLine = '';
            terminalReady = false;
        }
        
        function killProcess() {
            sendToKotlin({ command: 'killProcess' });
        }
        
        function checkStatus() {
            sendToKotlin({ command: 'checkTerminalStatus' });
        }
        
        function updateStatus(message, type) {
            const statusEl = document.getElementById('terminalStatus');
            statusEl.textContent = message;
            statusEl.className = 'status ' + type;
        }
        
        // KotlinÏóêÏÑú JavaScriptÎ°ú Î©îÏãúÏßÄÎ•º Î∞õÎäî Ìï∏Îì§Îü¨
        window.handleMessage = function(data) {
            console.log('Received from Kotlin:', data);
            
            switch (data.command) {
                case 'terminalReady':
                    terminalReady = true;
                    updateStatus('ÌôúÏÑ±', 'ready');
                    document.getElementById('terminalInfo').innerHTML = 
                        '‚úÖ IntelliJ ProcessHandlerÍ∞Ä ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§! (' + data.method + ')<br/>' +
                        'VS Code PseudoterminalÍ≥º ÎèôÏùºÌïú Î∞©ÏãùÏúºÎ°ú ÎèôÏûëÌï©ÎãàÎã§!';
                    break;
                    
                case 'terminalError':
                    updateStatus('Ïò§Î•ò', 'error');
                    document.getElementById('terminalInfo').innerHTML = 
                        '‚ùå ÌÑ∞ÎØ∏ÎÑê Ïò§Î•ò: ' + data.error;
                    if (term) {
                        term.write('\\r\\n\\x1b[31m‚ùå Ïò§Î•ò: ' + data.error + '\\x1b[0m\\r\\n\$ ');
                    }
                    break;
                    
                case 'terminalOutput':
                    if (term) {
                        term.write(data.data);
                    }
                    break;
                    
                case 'terminalTerminated':
                    terminalReady = false;
                    updateStatus('Ï¢ÖÎ£åÎê®', 'error');
                    document.getElementById('terminalInfo').innerHTML = 
                        'üîÑ ÌÑ∞ÎØ∏ÎÑêÏù¥ ÏôÑÏ†ÑÌûà Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§.<br/>' +
                        'ÏÉà ÌÑ∞ÎØ∏ÎÑêÏùÑ ÏÉùÏÑ±ÌïòÎ†§Î©¥ "ÌÑ∞ÎØ∏ÎÑê ÏÉùÏÑ±" Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî.';
                    
                    if (term) {
                        term.clear();
                        term.write('\\r\\n\\x1b[32m‚úÖ ÌÑ∞ÎØ∏ÎÑêÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§.\\x1b[0m\\r\\n');
                        term.write('\\x1b[36mÏÉà ÌÑ∞ÎØ∏ÎÑêÏùÑ ÏãúÏûëÌïòÎ†§Î©¥ "ÌÑ∞ÎØ∏ÎÑê ÏÉùÏÑ±" Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî.\\x1b[0m\\r\\n');
                    }
                    break;
                    
                case 'clearWebTerminal':
                    if (term) {
                        term.clear();
                        term.write('\$ ');
                        currentLine = '';
                    }
                    break;
                    
                case 'terminalStatus':
                    updateStatus(data.isActive ? 'ÌôúÏÑ±' : 'ÎπÑÌôúÏÑ±', data.isActive ? 'ready' : 'error');
                    document.getElementById('terminalInfo').innerHTML = 
                        'üìä ÌÑ∞ÎØ∏ÎÑê ÏÉÅÌÉú: ' + (data.isActive ? 'ÌôúÏÑ±' : 'ÎπÑÌôúÏÑ±') + '<br/>' +
                        'Ïã§Ìñâ Ï§ëÏù∏ ÌîÑÎ°úÏÑ∏Ïä§: ' + (data.hasRunningProcess ? 'ÏûàÏùå' : 'ÏóÜÏùå') + '<br/>' +
                        'ÌòÑÏû¨ ÎîîÎ†âÌÜ†Î¶¨: ' + data.currentDirectory;
                    break;
            }
        };
        
        // KotlinÏúºÎ°ú Î©îÏãúÏßÄ Î≥¥ÎÇ¥Îäî Ìï®Ïàò (window.sendToKotlinÏùÄ KotlinÏóêÏÑú Ï£ºÏûÖÎê®)
        function sendToKotlin(data) {
            if (window.sendToKotlin) {
                window.sendToKotlin(data);
            } else {
                console.error('Kotlin bridge not available');
            }
        }
        
        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú ÌÑ∞ÎØ∏ÎÑê Ï¥àÍ∏∞Ìôî
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                createTerminal();
            }, 1000); // IntelliJ JCEF Ï¥àÍ∏∞ÌôîÎ•º ÏúÑÌï¥ ÏïΩÍ∞ÑÏùò ÏßÄÏó∞
        });
    </script>
</body>
</html>
        """.trimIndent()
    }
}
